package app.getnuri.feature.feedback.entry

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import app.getnuri.data.UserFeedbackDao
import app.getnuri.data.UserFeedback // Import the UserFeedback data class
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

sealed interface SubmissionState {
    data object Idle : SubmissionState
    data object Saving : SubmissionState
    data object Saved : SubmissionState
    data class Error(val message: String) : SubmissionState
}

data class FeedbackEntryUiState(
    val mealId: Long = 0L, // Initialized to a default, will be set by setMealId
    val selectedFeeling: String = "",
    val customFeeling: String = "", // In case "Other" is selected, or for future use
    val notes: String = "",
    val submissionState: SubmissionState = SubmissionState.Idle
)

@HiltViewModel
class FeedbackEntryViewModel @Inject constructor(
    private val userFeedbackDao: UserFeedbackDao
) : ViewModel() {

    private val _uiState = MutableStateFlow(FeedbackEntryUiState())
    val uiState: StateFlow<FeedbackEntryUiState> = _uiState.asStateFlow()

    fun setMealId(mealId: Long) {
        // Only set if not already set, or if it's different and not currently saving
        if ((_uiState.value.mealId != mealId || _uiState.value.mealId == 0L) && _uiState.value.submissionState != SubmissionState.Saving) {
            _uiState.update { it.copy(mealId = mealId) }
        }
    }

    fun selectFeeling(feeling: String) {
        if (_uiState.value.submissionState != SubmissionState.Saving) {
            _uiState.update { it.copy(selectedFeeling = feeling) }
        }
    }

    fun updateNotes(notes: String) {
        if (_uiState.value.submissionState != SubmissionState.Saving) {
            _uiState.update { it.copy(notes = notes) }
        }
    }

    fun saveFeedback() {
        if (_uiState.value.selectedFeeling.isBlank()) {
            _uiState.update { it.copy(submissionState = SubmissionState.Error("Please select a feeling.")) }
            return
        }
        if (_uiState.value.mealId == 0L) {
             _uiState.update { it.copy(submissionState = SubmissionState.Error("Meal ID is not set.")) }
            return
        }

        _uiState.update { it.copy(submissionState = SubmissionState.Saving) }

        viewModelScope.launch {
            try {
                val feedback = UserFeedback(
                    // id is auto-generated by Room, so 0 is fine
                    mealId = _uiState.value.mealId,
                    feedbackTimestamp = System.currentTimeMillis(),
                    feelingDescription = _uiState.value.selectedFeeling,
                    customFeeling = if (_uiState.value.selectedFeeling == "Other") _uiState.value.customFeeling else null,
                    feedbackNotes = _uiState.value.notes.takeIf { it.isNotBlank() }
                )
                userFeedbackDao.insertFeedback(feedback)
                _uiState.update { it.copy(submissionState = SubmissionState.Saved) }
            } catch (e: Exception) {
                _uiState.update { it.copy(submissionState = SubmissionState.Error("Failed to save feedback: ${e.message}")) }
            }
        }
    }
    
    fun resetSubmissionState() {
         // Reset submission state, but keep mealId, feeling, and notes for now
         // If full reset is needed, that can be a separate function or controlled by screen logic
        _uiState.update { it.copy(submissionState = SubmissionState.Idle) }
    }
}
